%function rsfmri_preprocess(varargin)
% Task-free fMRI preprocessing script

% Requires: SPM12, FSL5
% Optional: R (for FSL ICA FIX classificaiton)

% Takes raw fMRI data as 3D .nii files
% Performs some or all of:
% structural skull-stripping, independent component analysis denoising,
% slice timing correction, realignment (motion correction), 
% coregistration (registration to structural scan),
% normalization (registration to standard space), spatial smoothing,
% bandpass temporal filtering

% Seeley Lab, 2009-2014
% Helen (Juan) Zhou
% Christine Guo
% Jesse Brown
% Andrew Trujillo

% inputs
% Subject list: this can be generated by PrepPreprocCloud.m or by GUI
%%% this structure must contain:
%%% 1) a variable called 'subjlist' that specifies each subject
%%% 2) a variable called 'fname' for each subject in subjlist that contains the list of full filepaths to each fMRI 3D .nii file
%%% 3) a variable called 'tname' for each subject in subjlist that
%%% specifies the full file path to the skull-stripped T1/structural image, eg 'LAS_HB10409_t1mprage.nii'
%%% 4) a variable called 'T1brain' for each subject in subjlist that specifies the full file path to the
%%% skull-stripped T1 image, eg 'LAS_HB10409_t1mprage_brain.nii'
load('loadsubfile');

% if script is called by GUI
if isfield(subjlist,'opt');gui=true;else gui=false;end

fid=fopen([subjlist.opt.preproc_root,'/Paths.txt']);
spmpath=textscan(fid,'%s');
spmpath=char(spmpath{1,1}); 

    
%rmpath(genpath('/usr/share/spm8'));
addpath(genpath(spmpath));



if gui
    files_dir=[subjlist.opt.preproc_root,'/proc'];
else
    files_dir='/data/mridata/truji/rsfmri_preprocess_files'; % directory where all support files are
end

% set up path
% NOTE: make sure SPM is added to matlab path
addpath(genpath(files_dir));
addpath(genpath(sprintf('$FSLDIR/etc/matlab')));
setenv('FSLOUTPUTTYPE','NIFTI');



% flags for steps to run/not run; note that subsequent steps may require files created at earlier stage
% NOTE: if ICA is set to true, realign, slicetime, and smooth are automatically set
% to false because these are handled internally by melodic, instead of with SPM
ica=true; % run melodic ICA
ica_fix=false; % run FSL FIX denoising after ICA
realign=true; % do motion correction; if ica=true, done with FSL; otherwise with SPM
slicetime=true; % do slice timing correction; if ica=true, done with FSL; otherwise with SPM
fsl_reg=false; % use FSL boundary-based registration + FLIRT/FNIRT normalization
spm_reg=true; % use SPM coregistration + normalizaiton
coreg=true; % only if spm_reg - do coregistration of EPI image to T1
norm=true; % only if spm_reg - do normalization of T1 to MNI standard brain
smooth=true; % do spatial smoothing
bptfilter=true; % do bandpass temporal filtering
bptfilter_nuisance=true; % apply same bandpass temporal filter to nuisance parameters (motion + ICA)
motion_spikes=true; % create dummy nuisance regressor for each TR with a motion spike
interleave=true; % use ica only to create nuisance regressors for interleave artifact components
nonlinear=false; % for fsl_reg, use FNIRT for non-linear normalization if true
new_segment=true; % for spm_reg, use SPM8 "new segment" instead of old
optibet=true; % use optibet for skull stripping instead of normal bet

% if GUI, load options from there (opt not used: trnum, scanner, fsl_ReSt
if gui
    fsl_ReSt=subjlist.opt.fsl_ReSt; 
    ica=subjlist.opt.IcaFull; % run melodic ICA
    bptfilter=subjlist.opt.filter; % do bandpass temporal filtering
    bptfilter_nuisance=subjlist.opt.mfilter; % apply same bandpass temporal filter to nuisance parameters (motion + ICA)
    motion_spikes=subjlist.opt.mspike; % create dummy nuisance regressor for each TR with a motion spike
    interleave=subjlist.opt.ileave; % use ica only to create nuisance regressors for interleave artifact components
end

% debug flags
ica_already_run=false; % if ICA has already been run and you don't need to run it again
complete_run=true; % only run specific steps of already-initiated preprocessing; must manually specify dir_suffix

% output directory names
rawfmri_dir='rawfmri'; % directory where raw fmri data are stored
interfmri_dir='interfmri'; % directory where all processed data up to normalized images are stored
processedfmri_dir='processedfmri'; % directory where processed data for bandpass filtered images are stored
log_dir='log';
melodic_dir='melodic.ica';

% fMRI specifications
TR=2;
n_scans_remove=5; % number of volumes excluded from beginning of BOLD fMRI scan
spike_cutoff=1; % amount of motion displacement in mm above which to flag a motion spike
interleave_cutoff=1260; % interleave score above which a component is identified as interleave
fix_thresh=20; % if running ICA + FIX, threshold for component exclusion; 20 is standard, exludes many comps; 10 is "lite", excludes fewer
nonlin_reg=10; % if running SPM normalization: amount of regularization. 1 is standard, 10 allows less warping.
struc_match_headers=false; % if skull stripping, copy header from skull stripped image to original structural image
slice_order=[2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35];

if gui
    TR=str2num(subjlist.opt.tr);
    n_scans_remove=str2num(subjlist.opt.delscans); % number of volumes excluded from beginning of BOLD fMRI scan
    spike_cutoff=str2num(subjlist.opt.mspikecutoff); % amount of motion displacement in mm above which to flag a motion spike
    interleave_cutoff=str2num(subjlist.opt.ileavecutoff); % interleave score above which a component is identified as interleave
    slice_order=str2num(subjlist.opt.sliceorder);
end

% template images
mni_head=sprintf('%s/MNI152_T1_2mm.nii',files_dir);
mni_brain=sprintf('%s/MNI152_T1_2mm_brain.nii',files_dir);
mni_brain_mask=sprintf('%s/MNI152_T1_2mm_brain_mask.nii',files_dir);

% bandpass filter frequency cutoffs (Hz)
lp_cutoff=.0083;
hp_cutoff=.15;
if gui
    lp_cutoff=str2num(subjlist.opt.lowFreq);
    hp_cutoff=str2num(subjlist.opt.highFreq); 
end 
fwhm_to_sigma=2.35;
LF=1/lp_cutoff/fwhm_to_sigma/TR;
HF=1/hp_cutoff/fwhm_to_sigma/TR;

% SPM job files with parameters specified
% NOTE: when these load, the structure is 'matlabbatch.matlabbatch'
joblist={};
% realignment
joblist{1}.matname=sprintf('%s/realign_unwarp.mat',files_dir);
% slice timing correction
joblist{2}.matname=sprintf('%s/slicetiming.mat',files_dir);
% normalization
if (~isempty(subjlist.tname{1}))
    joblist{3}.matname=sprintf('%s/normalize.mat',files_dir); % if the subjects have T1 images
else
    joblist{3}.matname=sprintf('%s/normalizeEPI_job_spm8.mat',files_dir);
end
% smoothing
joblist{4}.matname=sprintf('%s/smooth.mat',files_dir);
% coregistration
joblist{5}.matname=sprintf('%s/coregister.mat',files_dir);
% spm12 new segment + deformation for normalization
joblist{6}.matname=sprintf('%s/job_new_segment12.mat',files_dir);
joblist{7}.matname=sprintf('%s/job_deformations12.mat',files_dir);


%% Start processing
% setup directory suffix
% 'RTCN(n/)SF(m/n)DI'
if complete_run
    dir_suffix='';
    if realign;dir_suffix=strcat(dir_suffix,'R');end
    if slicetime;dir_suffix=strcat(dir_suffix,'T');end
    if spm_reg;
        if new_segment;
            dir_suffix=strcat(dir_suffix,'CNn');
        else
            dir_suffix=strcat(dir_suffix,'CN');
        end
    end
    if smooth;dir_suffix=strcat(dir_suffix,'S');end
    if bptfilter;if bptfilter_nuisance;dir_suffix=strcat(dir_suffix,'Fm');else;dir_suffix=strcat(dir_suffix,'Fn');end;end
    if interleave;dir_suffix=strcat(dir_suffix,'D');end
    if ica;dir_suffix=strcat(dir_suffix,'I');end
else
    dir_suffix='RTCNnSFmDI'; % if not complete_run, have to manually specify suffix
end

if gui
    dir_suffix=subjlist.opt.outstring; 
end

interfmri_dir=strcat(interfmri_dir,'_',dir_suffix);
processedfmri_dir=strcat(processedfmri_dir,'_',dir_suffix);
processedstruc_dir=['strucprocessed_',dir_suffix];

% setup filename prefixes
if fsl_reg;addstr_reg='bbr';else;addstr_reg='';end
if interleave;ica=true;end % sets ica to true so ICA components can be determined and assessed for interleave

if ica
    realign=false;
    slicetime=false;
    addstr_ica='d';
elseif ica_already_run
    addstr_ica='d';
else
    addstr_ica='';
end

% launch SPM
spm('Defaults','fmri')

n_scans=length(subjlist.fname); % number of fMRI volumes

[rspth,nam,ext]=fileparts(subjlist.fname{1,1});
if regexp(nam,'_');base_filename=nam(1:max(strfind(nam,'_')-1));else base_filename=nam;end  % fMRI prefix

% specify main rsfmri directory, eg /data6/controlNIC/8698/8698_20090408/rsfmri_new
rspth = regexprep(rspth, '/rawfmri', '');
rspth = regexprep(rspth, strcat('/',interfmri_dir), '');

rawfmri_dir_fullpth=strcat(rspth,'/',rawfmri_dir);
interfmri_dir_fullpth=strcat(rspth,'/',interfmri_dir);
interfmri_imgs_dir_fullpth=strcat(rspth,'/',interfmri_dir,'/images');
processedfmri_dir_fullpth=strcat(rspth,'/',processedfmri_dir);
processedfmri_imgs_dir_fullpth=strcat(rspth,'/',processedfmri_dir,'/images');
log_dir_fullpth=strcat(rspth,'/',interfmri_dir,'/',log_dir);

cd(rspth);
if ~exist(interfmri_dir);mkdir(interfmri_dir);end
interfmri_imgs_dir=strcat(interfmri_dir,'/','images');
if ~exist(interfmri_imgs_dir);mkdir(interfmri_imgs_dir);end

cmd=sprintf('mkdir -p %s',log_dir_fullpth);unix(cmd);
cmd=sprintf('mkdir -p %s',processedfmri_dir_fullpth);unix(cmd);
cmd=sprintf('mkdir -p %s',processedfmri_imgs_dir_fullpth);unix(cmd);

% copy raw data files from nii_dir to interfmri_dir
unix(sprintf('cp %s/*.nii %s',rawfmri_dir_fullpth,interfmri_imgs_dir_fullpth));

cd(sprintf('%s',interfmri_imgs_dir_fullpth));


%% 1. Structural path setup/skull strip
[t1pth,t1file,t1ext] = fileparts(subjlist.tname{1});
struc_dir_fullpth=regexprep(t1pth,'strucraw','');
struc_proc_dir_fullpth=[struc_dir_fullpth,processedstruc_dir];
if ~exist(struc_proc_dir_fullpth)
    mkdir(struc_proc_dir_fullpth)
    cmd=(['cp ', t1pth,'/* ',struc_proc_dir_fullpth]);
    unix(cmd);
end

T1brain_prefix=sprintf('%s/%s_brain',struc_proc_dir_fullpth,t1file);
subjlist.tname{1}=strcat(struc_proc_dir_fullpth,'/',t1file,t1ext);

nii_convert_struc=false;
if nii_convert_struc
    % if structural is ANALYZE, convert to NIFTI
    if strcmp(t1ext,'.img')
        % backup old file
        if isempty(dir([struc_proc_dir_fullpth,'/*.img']))
            subjlist.tname{1}=strcat(struc_proc_dir_fullpth,'/',t1file,'.nii');
        else
            cmd=sprintf('mkdir %s/old_analyze',struc_proc_dir_fullpth);
            unix(cmd);
            hdr=strcat(struc_proc_dir_fullpth,'/',t1file,'.hdr');
            cmd=sprintf('cp %s %s old_analyze',subjlist.tname{1},hdr);
            unix(cmd)
            
            cmd=sprintf('fslchfiletype NIFTI %s',subjlist.tname{1});
            unix(cmd)
            subjlist.tname{1}=strcat(struc_proc_dir_fullpth,'/',t1file,'.nii'); % update filename
        end
    end
end

update_t1_header=false; % old option; consider eliminating
if update_t1_header
    cmd=sprintf('fslorient -copyqform2sform %s',subjlist.tname{1});
    unix(cmd);
end

% Check if skull stripping has been done
% If multiple versions exists, delete all but one
% Order of preference is 1) .nii, 2) .img/.hdr
if length(dir(strcat(T1brain_prefix,'.nii.gz')))
    cmd=sprintf('gunzip %s.nii.gz',T1brain_prefix);
    unix(cmd);
    subjlist.T1brain=strcat(T1brain_prefix,'.nii');
    if length(dir(strcat(T1brain_prefix,'.img')))
        unix(sprintf('rm %s.img',T1brain_prefix));
        unix(sprintf('rm %s.hdr',T1brain_prefix));
    end
elseif length(dir(strcat(T1brain_prefix,'.nii')))
    subjlist.T1brain=strcat(T1brain_prefix,'.nii');
    if length(dir(strcat(T1brain_prefix,'.img')))
        unix(sprintf('rm %s.img',T1brain_prefix));
        unix(sprintf('rm %s.hdr',T1brain_prefix));
    end
elseif length(dir(strcat(T1brain_prefix,'.img')))
    unix(sprintf('rm %s.img',T1brain_prefix));
    unix(sprintf('rm %s.hdr',T1brain_prefix));
    t1pth_file=strcat(struc_proc_dir_fullpth,'/',t1file);
    if optibet
        cmd=sprintf('%s/optiBET.sh -i %s',files_dir,t1pth_file);
        unix(cmd);
    else
        cmd=sprintf('bet %s %s_brain -B -f 0.2 -g 0',t1pth_file,t1pth_file);
        fsl_matlab(cmd);
    end
    
    if exist(sprintf('%s.nii.gz',T1brain_prefix),'file')
        if exist(sprintf('%s.nii',T1brain_prefix),'file')
            cmd=sprintf('rm %s.nii',T1brain_prefix);
            unix(cmd);
        end
        cmd=sprintf('gunzip %s.nii.gz',T1brain_prefix);
        unix(cmd);
    end
    subjlist.T1brain=strcat(T1brain_prefix,'.nii');
else
    t1pth_file=strcat(struc_proc_dir_fullpth,'/',t1file);
    if optibet
        cmd=sprintf('%s/optiBET.sh -i %s',files_dir,t1pth_file);
        unix(cmd);
    else
        cmd=sprintf('bet %s %s_brain -B -f 0.2 -g 0',t1pth_file,t1pth_file);
        fsl_matlab(cmd);
    end
    
    if exist(sprintf('%s.nii.gz',T1brain_prefix),'file')
        if exist(sprintf('%s.nii',T1brain_prefix),'file')
            cmd=sprintf('rm %s.nii',T1brain_prefix);
            unix(cmd);
        end
        cmd=sprintf('gunzip %s.nii.gz',T1brain_prefix);
        unix(cmd);
    end
    subjlist.T1brain=strcat(T1brain_prefix,'.nii');
    
    if struc_match_headers
        cmd=sprintf('fslcpgeom %s %s',t1pth_file,subjlist.T1brain);
        fsl_matlab(cmd);
    end
end

cd(sprintf('%s/%s',rspth,interfmri_dir));

%% 2. ICA denoising
% run 1) slice timing correction, 2) motion correction, 3) ICA
% pass slice time corrected/motion corrected data on for subsequent processing
if ica
    if ~ica_already_run
        n_slices=length(slice_order);
        out_str='';
        for i=1:n_slices
            slice_num=slice_order(i);
            out_str=sprintf('%s%d\n',out_str,slice_num);
        end
        
        slice_order_file=sprintf('%s/slice_order.txt',interfmri_dir_fullpth);
        f=fopen(slice_order_file,'w');
        fprintf(f,'%s',out_str);
        fclose(f);
        
        melodic_design_template=sprintf('%s/melodic_design_template.fsf',files_dir)
        melodic_design_file='melodic_design.fsf';
        
        merge='';
        for n=1:n_scans
            merge=sprintf('%s %s',merge,subjlist.fname{n,:});
        end
        
        melodic_file=sprintf('%s/%s/%s_merged',rspth,interfmri_imgs_dir,base_filename);
        cmd=sprintf('fslmerge -t %s %s',melodic_file,merge);
        fsl_matlab(cmd,false);
        
        % Run slice timing correction
        melodic_file_st=sprintf('%s/%s/%s_merged_st',rspth,interfmri_imgs_dir,base_filename);
        cmd=sprintf('slicetimer -i %s --out=%s -r %d --ocustom=%s',melodic_file,melodic_file_st,TR,slice_order_file);
        unix(cmd);
        
        % Run motion correction (realignment)
        melodic_file_mc=sprintf('%s/%s/%s_merged_mcf',rspth,interfmri_imgs_dir,base_filename);
        cmd=sprintf('mcflirt -in %s -out %s',melodic_file_st,melodic_file_mc);
        unix(cmd);
        
        % Setup melodic design file, specifying subject specific parameters
        % BOLD data file
        cmd=sprintf('sed "s|/data6/mridata6/Hillblom/2679/2679_20100921/rsfmri/orig2/RestingState25x25x3_merged|%s|g" %s > melodic_design_temp1',melodic_file_mc,melodic_design_template);
        unix(cmd);
        % skull-stripped T1 file
        cmd=sprintf('sed "s|/data6/mridata6/Hillblom/2679/2679_20100921/struc/MP-LAS_GHB048X2_brain|%s|g" melodic_design_temp1 > melodic_design_temp2',subjlist.T1brain);
        unix(cmd);
        % TR
        cmd=sprintf('sed "s|set fmri(tr) 2.0|set fmri(tr) %s|g" melodic_design_temp2 > melodic_design_temp3',num2str(TR));
        unix(cmd);
        % number of volumes
        cmd=sprintf('sed "s|set fmri(npts) 235|set fmri(npts) %s|g" melodic_design_temp3 > melodic_design_temp4',num2str(n_scans));
        unix(cmd);
        % output directory
        cmd=sprintf('sed "s|set fmri(outputdir) \"melodic\"|set fmri(outputdir) \"%s/melodic\"|g" melodic_design_temp4 > melodic_design_temp5',interfmri_dir_fullpth);
        unix(cmd);
        
        % total number of voxels in all volumes combined
        cmd=sprintf('fslstats %s -v',melodic_file_mc);
        [status,n_vox_str]=unix(cmd);
        n_vox_str_split=regexp(n_vox_str,' ','split');
        n_vox=n_vox_str_split{1};
        cmd=sprintf('sed "s|set fmri(totalVoxels) 71605440|set fmri(totalVoxels) %s|g" melodic_design_temp5 > %s',n_vox,melodic_design_file);
        unix(cmd);
        
        % clean up
        cmd='rm melodic_design_temp*';
        unix(cmd);
        
        % If previous melodic.ica dirs exist, delete them
        previous_melodic_dirs=dir('melodic*.ica');
        if length(previous_melodic_dirs) > 0
            cmd='rm -r melodic*.ica';
            %unix(cmd)
        end
        
        setenv('SGE_ROOT',''); % disable SGE so job doesn't submit to cluster
        
        cmd=sprintf('feat %s',melodic_design_file);
        unix(cmd);
        
        % move melodic design file to log directory
        cmd=sprintf('mv %s/melodic_design.fsf %s',interfmri_dir_fullpth,log_dir_fullpth);unix(cmd);
        
        if ica_fix
            % make sure versions of shared objects are same for MATLAB and R
            setenv( 'LD_LIBRARY_PATH', strcat( '/usr/lib/x86_64-linux-gnu:', getenv( 'LD_LIBRARY_PATH' ) ) );
            
            % run FSL FIX
            fix_dir=sprintf('%s/fix1.05',files_dir);
            % feature extraction
            cmd=sprintf('%s/fix -f %s',fix_dir,melodic_dir);
            unix(cmd);
            % classify components
            if interleave
                fix_thresh=20; % always use standard cutoff when using ica for interleave detection
            end
            cmd=sprintf('%s/fix -c %s %s/training_files/Standard.RData %d',fix_dir,melodic_dir,fix_dir,fix_thresh);
            unix(cmd);
            
            component_ts=load(sprintf('%s/filtered_func_data.ica/melodic_Tmodes',melodic_dir));
            bad_components=load(sprintf('%s/.fix',melodic_dir));
            bad_component_ts=component_ts(:,bad_components);
            save(sprintf('%s/bad_components_regressors.txt',melodic_dir),'bad_component_ts','-ascii');
        end
        
        if interleave
            ic_file=sprintf('%s/filtered_func_data.ica/melodic_IC.nii',melodic_dir);
            in=spm_vol(ic_file);
            data=spm_read_vols(in);
            data=abs(data);
            n_comp=size(data,4);
            odds=1:2:size(data,3);
            evens=2:2:size(data,3);
            
            for i=1:n_comp
                ic=data(:,:,:,i);
                slice_sums=squeeze(sum(sum(ic,1)));
                odd_even_dif(i)=mean(slice_sums(evens))-mean(slice_sums(odds));
            end
            
            odd_even_dif=abs(odd_even_dif);
            interleave_ics=find(odd_even_dif>interleave_cutoff);
            
            interleave_file=sprintf('%s/interleave_ics.txt',melodic_dir);
            fid=fopen(interleave_file,'wt');
            fprintf(fid,'%d\n',interleave_ics);
            fclose(fid);
            
            interleave_scores_file=sprintf('%s/interleave_ic_scores.txt',melodic_dir);
            fid=fopen(interleave_scores_file,'wt');
            fprintf(fid,'%d\n',odd_even_dif);
            fclose(fid);
            
            component_ts=load(sprintf('%s/filtered_func_data.ica/melodic_Tmodes',melodic_dir));
            bad_components=load(sprintf('%s/interleave_ics.txt',melodic_dir))';
            bad_component_ts=component_ts(:,bad_components);
            save(sprintf('%s/bad_components_regressors.txt',melodic_dir),'bad_component_ts','-ascii');
        end
        
        setup_ica=true;
        if setup_ica
            denoised_file=sprintf('%s/%s_merged_mcf',interfmri_imgs_dir_fullpth,base_filename);
            
            % split and rename files
            addstr=strcat(addstr_ica,'ua');
            cmd=sprintf('fslsplit %s %s/%s%s_ -t',denoised_file,interfmri_imgs_dir_fullpth,addstr,base_filename);
            fsl_matlab(cmd,false);
            for n=1:n_scans
                n_shift=n-1; % fslsplit starts at 0, not 1
                n_out=n+n_scans_remove;
                cmd=sprintf('mv %s/%s%s_%04d.nii %s/%s%s_%03d.nii',interfmri_imgs_dir_fullpth,addstr,base_filename,n_shift,interfmri_imgs_dir_fullpth,addstr,base_filename,n_out);
                unix(cmd);
            end
            
            % generate unsmoothed mean functional image for spm coregistration
            cmd=sprintf('fslmaths %s -Tmean %s/mean_func_unsmoothed',melodic_file_mc,melodic_dir);
            fsl_matlab(cmd,false);
        end
    end
end

%% 3a. Motion spike detection
if motion_spikes
    % create 4D nii file
    merge='';
    for n=1:n_scans
        merge=sprintf('%s %s',merge,subjlist.fname{n,:});
    end
    
    merged_file=sprintf('%s_merged',base_filename);
    
    cmd=sprintf('fslmerge -t %s %s',merged_file,merge);
    fsl_matlab(cmd,false);
    
    % run MCFLIRT
    motion_dir='motion_corr';
    cmd=sprintf('mkdir %s/motion_corr',interfmri_dir_fullpth);
    unix(cmd);
    
    refvol=floor(n_scans/2);
    cmd=sprintf('mcflirt -in %s -out motion_corr/%s_mcf -mats -plots -refvol %d -rmsrel -rmsabs',merged_file,merged_file,refvol);
    fsl_matlab(cmd,false);
    
    cmd=sprintf('fsl_tsplot -i motion_corr/%s_mcf_abs.rms,motion_corr/%s_mcf_rel.rms -t "MCFLIRT estimated mean displacement (mm)" -u 1 -w 640 -h 144 -a absolute,relative -o motion_corr/disp.png',merged_file,merged_file);
    fsl_matlab(cmd,false);
    
    % create motion spike regressors
    motion=load(sprintf('motion_corr/%s_mcf_rel.rms',merged_file));
    motion=[0;motion]; % prepend zero because motion is relative to first frame
    bad=find(motion>spike_cutoff);
    n_bad=length(bad);
    spike_regressors=zeros(length(motion),n_bad);
    for i=1:n_bad
        spike_regressors(bad(i),i)=1;
    end
    
    spike_regressors_file=strcat('motion_corr','/','spike_regressors.txt');
    save(spike_regressors_file,'spike_regressors','-ascii');
    
    % generate motion report and save motion statistics
    motion_par_file=sprintf('%s/motion_corr/%s_merged_mcf.par',interfmri_dir_fullpth,base_filename);
    motion_report_img=sprintf('%s/%s/motion_report',interfmri_dir_fullpth,motion_dir);
    motion_stats_file=sprintf('%s/%s/motion_stats.mat',interfmri_dir_fullpth,motion_dir);
    [mean_disp,std_disp,max_disp,sum_disp,n_spikes,mean_transrms,std_transrms,max_transrms,sum_transrms,max_trans,mean_euler,std_euler,max_euler,sum_euler,max_rot]= motion_qa(motion_par_file,false,n_scans,spike_cutoff,motion_report_img);
    save(motion_stats_file,'mean_disp','std_disp','max_disp','sum_disp','n_spikes','mean_transrms','std_transrms','max_transrms','sum_transrms','max_trans','mean_euler','std_euler','max_euler','sum_euler','max_rot');
end

%% 3. Slice timing correction
% output files will have 'u' prefix
if slicetime
    matlabbatch=load(joblist{2}.matname);
    matlabbatch=matlabbatch.matlabbatch;
    
    matlabbatch{1}.spm.temporal.st.scans{1} = {};
    
    % input images
    for n = 1:n_scans
        fname=regexprep(subjlist.fname{n,:},strcat('/','rawfmri'),strcat('/',interfmri_imgs_dir)); % update filename to data copied into interfmri_imgs_dir
        matlabbatch{1}.spm.temporal.st.scans{1}{n} = fname;
    end
    
    Vin = spm_vol(matlabbatch{1}.spm.temporal.st.scans{1}{n}); % the number of scans
    nslices = Vin(1).dim(3);
    matlabbatch{1}.spm.temporal.st.nslices = nslices;
    
    matlabbatch{1}.spm.temporal.st.tr = TR;
    matlabbatch{1}.spm.temporal.st.ta = TR - TR/nslices;
    
    matlabbatch{1}.spm.temporal.st.so=slice_order;
    
    % specify the reference slice number
    matlabbatch{1}.spm.temporal.st.refslice = matlabbatch{1}.spm.temporal.st.so(round(nslices/2));
    
    save('./job_slice_timing.mat','matlabbatch');
    spm_jobman('run', matlabbatch);
end

%% 4. Realignment (motion correction)
% output files will have 'ua' prefix
addstr='a';
if realign
    matlabbatch=load(joblist{1}.matname);
    matlabbatch=matlabbatch.matlabbatch;
    
    matlabbatch{1,1}.spm.spatial.realignunwarp.data.scans = {};
    
    % input images
    for n = 1:n_scans
        [pth,nam,ext] = fileparts(subjlist.fname{n,:});
        matlabbatch{1,1}.spm.spatial.realignunwarp.data.scans{n} = strcat(interfmri_imgs_dir_fullpth,'/',addstr,nam,ext);
    end
    
    save('./job_realign.mat','matlabbatch');
    spm_jobman('run', matlabbatch);
end

%% 5. FSL coregistration of fMRI to T1 + normalization of T1 to standard
% output files will have 'ua' prefix (overwritten slice-time corrected files)
% NOTE: this section is not well tested
addstr=strcat(addstr_ica,'ua');
if fsl_reg
    cd(sprintf('%s',interfmri_imgs_dir_fullpth));
    [pth,nam,ext] = fileparts(subjlist.fname{1,1});
    
    cur_dir=interfmri_imgs_dir_fullpth;
    addstr=strcat('w',addstr_reg,addstr_ica,'ua');
    instr=strcat(addstr_ica,'ua');
    
    % use example functional image as reference
    if exist(strcat(interfmri_dir_fullpth,'/',melodic_dir,'/','example_func.nii'))
        reference_file = strcat(interfmri_dir_fullpth,'/',melodic_dir,'/','example_func.nii');
    else
        reference_file=strcat(cur_dir,'/',addstr,base_filename,'_006.nii'); % first BOLD 3D volume
    end
    
    % run BBR registration
    cmd=sprintf('epi_reg --epi=%s --t1=%s --t1brain=%s --out=%s/example_func2highres',reference_file,subjlist.tname{1},subjlist.T1brain,cur_dir);
    fsl_matlab(cmd,false);
    
    cmd=sprintf('convert_xfm -inverse -omat %s/highres2example_func.mat %s/example_func2highres.mat',cur_dir,cur_dir);
    fsl_matlab(cmd,false);
    
    % register t1 to standard
    cmd=sprintf('flirt -in %s -ref %s -out %s/highres2standard -omat %s/highres2standard.mat -cost corratio -dof 12 -searchrx -90 90 -searchry -90 90 -searchrz -90 90 -interp trilinear',subjlist.T1brain,mni_brain,cur_dir,cur_dir);
    fsl_matlab(cmd,false);
    
    cmd='convert_xfm -omat example_func2standard.mat -concat highres2standard.mat example_func2highres.mat';
    fsl_matlab(cmd,false);
    
    if nonlinear
        % non-linear register t1 to standard
        cmd=sprintf('fnirt --in=%s --aff=%s/highres2standard.mat --cout=highres2standard_warp --iout=highres2standard --jout=highres2highres_jac --config=T1_2_MNI152_2mm --ref=%s --refmask=%s --warpres=10,10,10 --imprefm=0 --impinm=0',subjlist.tname{1},cur_dir,mni_head,mni_brain_mask);
        fsl_matlab(cmd,false);
        
        cmd=sprintf('applywarp -i %s -r %s -o highres2standard -w highres2standard_warp',subjlist.T1brain,mni_brain);
        fsl_matlab(cmd,false);
        
        cmd=sprintf('convertwarp --ref=%s --premat=example_func2highres.mat --warp1=highres2standard_warp --out=example_func2standard_warp',mni_brain);
        fsl_matlab(cmd,false);
    end
    
    for n=1:n_scans
        n_out=n+n_scans_remove;
        cur_file=sprintf('%s/%s%s_%03d.nii',interfmri_imgs_dir_fullpth,instr,base_filename,n_out);
        out_file=sprintf('%s/%s%s_%03d.nii',interfmri_imgs_dir_fullpth,addstr,base_filename,n_out);
        if nonlinear
            cmd=sprintf('applywarp --ref=%s --in=%s --out=%s --warp=example_func2standard_warp',mni_brain,cur_file,out_file);
            fsl_matlab(cmd,false);
        else
            cmd=sprintf('flirt -in %s -ref %s -applyxfm -init example_func2standard.mat -out %s',cur_file,mni_brain,out_file);
            fsl_matlab(cmd,false);
        end
    end
    cd(sprintf('%s/%s',rspth,interfmri_dir));
end

%% 6. SPM coregistration of fMRI to T1 + normalization of T1 to standard
% output files will have some variant of 'w*ua' prefix
if spm_reg
    if coreg
        % if the subject has a T1
        if (length(subjlist.tname{1})~=0)
            matlabbatch=load(joblist{5}.matname);
            matlabbatch=matlabbatch.matlabbatch;
            
            % specify coregistration reference image (the skull stripped T1)
            matlabbatch{1}.spm.spatial.coreg.estimate.ref={};
            matlabbatch{1}.spm.spatial.coreg.estimate.ref{1} = subjlist.T1brain;
            
            % specify coregistration source image (the mean functional after realignment, before smoothing)
            [pth,nam,ext] = fileparts(subjlist.fname{1,1});
            
            if exist(strcat(interfmri_dir_fullpth,'/',melodic_dir,'/','mean_func_unsmoothed.nii')) ||  exist(strcat(interfmri_dir_fullpth,'/',melodic_dir,'/','mean_func_unsmoothed.nii.gz'))
                mean_func_pre = strcat(interfmri_dir_fullpth,'/',melodic_dir,'/','mean_func_unsmoothed.nii.gz');
                cmd=sprintf('gunzip %s',mean_func_pre);
                unix(cmd);
                mean_func = strcat(interfmri_dir_fullpth,'/',melodic_dir,'/','mean_func_unsmoothed.nii');
            else
                mean_func = strcat(interfmri_imgs_dir_fullpth,'/','mean','u',nam,ext); % mean func is created during realignment and only has 'u' prefix
            end
            matlabbatch{1}.spm.spatial.coreg.estimate.source = {};
            matlabbatch{1}.spm.spatial.coreg.estimate.source{1} = mean_func;
            
            % specify co-registered file output names with 'ua' prefix
            % (overwrite slice time-corrected files)
            matlabbatch{1}.spm.spatial.coreg.estimate.other={};
            for n = 1:n_scans
                n_out=n+n_scans_remove;
                out_file=sprintf('%s/%s%s_%03d.nii',interfmri_imgs_dir_fullpth,addstr,base_filename,n_out);
                matlabbatch{1}.spm.spatial.coreg.estimate.other{n} = out_file;
            end
        end
        
        save('./job_coreg.mat','matlabbatch');
        spm_jobman('run',matlabbatch);
    end
    
    if norm
        if new_segment
            % new_segment runs in two parts: 1) segmentation, 2) applying deformations
            load(joblist{6}.matname);
            struc_file=strcat(struc_proc_dir_fullpth,'/',t1file,t1ext);
            matlabbatch{1}.spm.spatial.preproc.channel.vols={strcat(struc_file,',1')};
            save('./job_new_segment12.mat','matlabbatch');
            spm_jobman('run',matlabbatch);
            
            load(joblist{7}.matname);
            deform_img_file=strcat(struc_proc_dir_fullpth,'/','y_',t1file,'.nii');
            matlabbatch{1}.spm.util.defs.comp{1}.def={deform_img_file};
            
            % specify files to normalize
            matlabbatch{1}.spm.util.defs.out{1}.pull.fnames={};
            for n = 1:n_scans
                n_out=n+n_scans_remove;
                out_file=sprintf('%s/%s%s_%03d.nii',interfmri_imgs_dir_fullpth,addstr,base_filename,n_out);
                matlabbatch{1}.spm.util.defs.out{1}.pull.fnames{n} = out_file;
            end
            last_file_norm=sprintf('%s/w%s%s_%03d.nii',interfmri_imgs_dir_fullpth,addstr,base_filename,n_out);
            
            matlabbatch{1}.spm.util.defs.out{1}.pull.savedir.saveusr={interfmri_imgs_dir_fullpth};
            
            save('./job_deformations12.mat','matlabbatch');
            spm_jobman('run',matlabbatch);
        else
            load(joblist{3}.matname);
            matlabbatch{1}.spm.spatial.normalise.estwrite.subj.resample = {};
            
            % specify files to normalize
            matlabbatch{1}.spm.spatial.normalise.estwrite.subj.resample={};
            for n = 1:n_scans
                n_out=n+n_scans_remove;
                out_file=sprintf('%s/%s%s_%03d.nii',interfmri_imgs_dir_fullpth,addstr,base_filename,n_out);
                matlabbatch{1}.spm.spatial.normalise.estwrite.subj.resample{n} = out_file;
            end
            last_file_norm=sprintf('%s/w%s%s_%03d.nii',interfmri_imgs_dir_fullpth,addstr,base_filename,n_out);
            
            % if the subject does not have a T1
            matlabbatch{1}.spm.spatial.normalise.estwrite.subj.vol={};
            if (length(subjlist.tname{1})==0)
                % specify mean functional as normalization source image
                mean_func = strcat(interfmri_imgs_dir_fullpth,'/','mean',addstr,nam,ext);
                matlabbatch{1}.spm.spatial.normalise.estwrite.subj.vol{1} = mean_func;
            % if the subject has a T1
            else
                % specify T1 as normalization source image
                matlabbatch{1}.spm.spatial.normalise.estwrite.subj.vol{1} = subjlist.tname{1};
                %matlabbatch{1}.spm.spatial.normalise.estwrite.eoptions.reg=nonlin_reg;
            end
            
            save('./job_normalize.mat','matlabbatch');
            spm_jobman('run',matlabbatch);
        end
        % create registration image
        cmd=sprintf('cp %s example_func2standard.nii',last_file_norm);
        unix(cmd);
        cmd=sprintf('slicer example_func2standard %s -s 2 -x 0.35 sla.png -x 0.45 slb.png -x 0.55 slc.png -x 0.65 sld.png -y 0.35 sle.png -y 0.45 slf.png -y 0.55 slg.png -y 0.65 slh.png -z 0.35 sli.png -z 0.45 slj.png -z 0.55 slk.png -z 0.65 sll.png',mni_brain);
        fsl_matlab(cmd);
        cmd='pngappend sla.png + slb.png + slc.png + sld.png + sle.png + slf.png + slg.png + slh.png + sli.png + slj.png + slk.png + sll.png example_func2standard1.png';
        fsl_matlab(cmd);
        cmd=sprintf('slicer %s example_func2standard -s 2 -x 0.35 sla.png -x 0.45 slb.png -x 0.55 slc.png -x 0.65 sld.png -y 0.35 sle.png -y 0.45 slf.png -y 0.55 slg.png -y 0.65 slh.png -z 0.35 sli.png -z 0.45 slj.png -z 0.55 slk.png -z 0.65 sll.png',mni_brain);
        fsl_matlab(cmd);
        cmd='pngappend sla.png + slb.png + slc.png + sld.png + sle.png + slf.png + slg.png + slh.png + sli.png + slj.png + slk.png + sll.png example_func2standard2.png';
        fsl_matlab(cmd);
        cmd='pngappend example_func2standard1.png - example_func2standard2.png example_func2standard.png';
        fsl_matlab(cmd);
        cmd='rm -f sl?.png example_func2standard2.png';
        unix(cmd);
        
        % move job files to log directory
        cmd=sprintf('mv %s/job*.mat %s',interfmri_dir_fullpth,log_dir_fullpth);unix(cmd);
    end
end

%% 7. Spatial smoothing
% output files will have some variant of 'sw*ua' prefix
% output files are stored in separate directory: smoothed/
addstr=strcat('w',addstr_reg,addstr_ica,'ua');
if smooth
    matlabbatch=load(joblist{4}.matname);
    matlabbatch=matlabbatch.matlabbatch;
    matlabbatch{1}.spm.spatial.smooth.data = {};
    
    % specify files to smooth
    for n = 1:n_scans
        n_out=n+n_scans_remove;
        out_file=sprintf('%s%s_%03d.nii',addstr,base_filename,n_out);
        matlabbatch{1}.spm.spatial.smooth.data{n} = strcat(interfmri_imgs_dir_fullpth,'/',out_file);
    end
    
    save('./job_smooth.mat','matlabbatch');
    spm_jobman('run',matlabbatch);
    
    % directory to store smoothed images
    addstr=strcat('sw',addstr_reg,addstr_ica,'ua');
    cd(rspth)
    
    %  move job files to log directory
    cmd=sprintf('mv %s/job*.mat %s/spm_*.ps %s',interfmri_dir_fullpth,interfmri_dir_fullpth,log_dir_fullpth);unix(cmd);
end

%% 8. Bandpass temporal filtering
% H_sigma (low frequency), L_sigma (High frequency)
% Nonlinear highpass and gaussian linear low pass with sigmas in number of volumes (scans), not seconds of the data
% output files will have some variant of 'swua_filteredf' prefix
% output files are stored in separate directory: smoothed_filtered/
addstr=strcat('sw',addstr_reg,addstr_ica,'ua');

if bptfilter
    cd(interfmri_imgs_dir_fullpth)
    
    % merge smoothed files to create 4D nii file for FSL
    merge_files='';
    for n=1:n_scans
        n_out=n+n_scans_remove;
        out_file=sprintf('%s%s_%03d.nii',addstr,base_filename,n_out);
        merge_files=sprintf('%s %s',merge_files,out_file);
    end
    
    cmd=sprintf('fslmerge -t %s/%s_merged %s',interfmri_imgs_dir_fullpth,addstr,merge_files);
    fsl_matlab(cmd,false);
    
    % run bandpass temporal filtering
    cmd=sprintf('fslmaths %s/%s_merged.nii -bptf %d %d %s/%s_merged_filtered',interfmri_imgs_dir_fullpth,addstr,LF,HF,interfmri_imgs_dir_fullpth,addstr);
    fsl_matlab(cmd,false);
    
    % if bandpass filter demeans each voxel (after fslmaths > version 5.0.7), calculate the voxelwise mean and add it back to the filtered data
    filter_remean=true;
    if filter_remean
        demean_cutoff=1; % value under which it is considered that fslmaths has demeaned the image
        cmd=sprintf('fslmaths %s/%s_merged -Tmean %s/%s_merged_mean',interfmri_imgs_dir_fullpth,addstr,interfmri_imgs_dir_fullpth,addstr);
        fsl_matlab(cmd,false);
        
        cmd=sprintf('fslstats %s/%s_merged_filtered -M',interfmri_imgs_dir_fullpth,addstr);
        grand_mean=fsl_matlab(cmd,false);grand_mean=str2num(grand_mean);
        if grand_mean < demean_cutoff
            cmd=sprintf('fslmaths %s/%s_merged_filtered -add %s/%s_merged_mean  %s/%s_merged_filtered',interfmri_imgs_dir_fullpth,addstr,interfmri_imgs_dir_fullpth,addstr,interfmri_imgs_dir_fullpth,addstr);
            fsl_matlab(cmd,false);
        end
    end
    
    % split 4D file back into separate 3D files
    cmd=sprintf('fslsplit %s/%s_merged_filtered %s/%s_filteredf_',interfmri_imgs_dir_fullpth,addstr,processedfmri_imgs_dir_fullpth,addstr);
    fsl_matlab(cmd,false);
    
    % delete 4D files
    cmd=sprintf('rm %s/%s_merged.nii  %s/%s_merged.nii %s/%s_merged_filtered.nii',interfmri_imgs_dir_fullpth,base_filename,interfmri_imgs_dir_fullpth,addstr,interfmri_imgs_dir_fullpth,addstr);
    unix(cmd);
end

%% 9. Configure motion parameters and nuisance ICA parameters
if bptfilter_nuisance
    cd(interfmri_imgs_dir_fullpth)
    mp_files=dir('motion_params*');if size(mp_files,1)>0;cmd='rm motion_params*';unix(cmd);end
    
    merged_file=sprintf('%s_merged',base_filename);
    
    % get motion parameters from 1) FSL melodic.ica/mc dir, 2) mcflirt params from motion spike detetcion, or 3) SPM realignment rp_*.txt file
    if exist(sprintf('%s/%s/mc/prefiltered_func_data_mcf.par',interfmri_dir_fullpth,melodic_dir))
        motion_file_fullpth=sprintf('%s/%s/mc/prefiltered_func_data_mcf.par',interfmri_dir_fullpth,melodic_dir);
        motion_file=dir(motion_file_fullpth);
    elseif exist(sprintf('%s/motion_corr/%s_mcf.par',interfmri_dir_fullpth,merged_file))
        motion_file_fullpth=sprintf('%s/motion_corr/%s_mcf.par',interfmri_dir_fullpth,merged_file);
        motion_file=dir(motion_file_fullpth);
    else
        motion_file_fullpth=sprintf('%s/rp*.txt',interfmri_dir_fullpth);
        motion_file=dir(motion_file_fullpth);
    end
    motion_data=load(motion_file_fullpth);
    
    % Bandpass filter motion paramaters
    % Creates "pseudo" .nii file out of motion parameters so fslmaths can be used to perform filtering
    cmd=sprintf('fslascii2img %s 6 1 1 %d 1 1 1 %d motion_params',motion_file_fullpth,n_scans,TR);
    fsl_matlab(cmd,false);
    cmd=sprintf('fslmaths motion_params.nii -bptf %d %d motion_params_filtered',LF,HF);
    fsl_matlab(cmd,false);
    
    % Create text files from .nii file
    cmd='fsl2ascii motion_params_filtered motion_params_filtered';
    fsl_matlab(cmd,false);
    % Merge all files into one file
    cmd='for i in `ls motion_params_filtered00*`; do cat $i >> motion_params_filtered_pre.txt; done';
    unix(cmd);
    % Remove blank lines
    cmd='sed "/^$/d" motion_params_filtered_pre.txt > motion_params_filtered.txt';
    unix(cmd);
    % Clean up
    cmd='rm motion_params.nii motion_params_filtered.nii motion_params_filtered_pre.txt motion_params_filtered00*';unix(cmd);
    cmd=sprintf('mv motion_params_filtered.txt %s',processedfmri_dir_fullpth);unix(cmd);
    
    if (ica_fix || interleave)
        % get bad ica component timeseries'
        ica_file_fullpth=sprintf('%s/%s/bad_components_regressors.txt',interfmri_dir_fullpth,melodic_dir);
        ica_data=load(ica_file_fullpth);
        n_comps=size(ica_data,2);
        
        if n_comps > 0
            % Bandpass filter ica components
            % Creates "pseudo" .nii file out of bad ica components so fslmaths can be used to perform filtering
            cmd=sprintf('fslascii2img %s %d 1 1 %d 1 1 1 %d bad_components',ica_file_fullpth,n_comps,n_scans,TR);
            fsl_matlab(cmd,false);
            cmd=sprintf('fslmaths bad_components.nii -bptf %d %d bad_components_filtered',LF,HF);
            fsl_matlab(cmd,false);
            
            % Create text files from .nii file
            cmd='fsl2ascii bad_components_filtered bad_components_filtered';
            fsl_matlab(cmd,false);
            % Merge all files into one file
            cmd='for i in `ls bad_components_filtered00*`; do cat $i >> bad_components_filtered_pre.txt; done';
            unix(cmd);
            % Remove blank lines
            cmd='sed "/^$/d" bad_components_filtered_pre.txt > bad_components_filtered.txt';
            unix(cmd);
            % Clean up
            cmd='rm bad_components.nii bad_components_filtered.nii bad_components_filtered_pre.txt bad_components_filtered00*';unix(cmd);
            cmd=sprintf('mv bad_components_filtered.txt %s',processedfmri_dir_fullpth);unix(cmd);
        end
    end
end
